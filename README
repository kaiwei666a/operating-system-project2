Project 3
Group members: Kai Wei, Alexander Lapsley, Ifeoluwa Olusola (Same as last project)
Modified Files: All the screenshors for tests in 'project 3_screenshots' folder.
                Makefile, Trap.c, Sysproc.c, 



Part 1: 
Understanding sbrk() 
How page allocation is implemented in xv6 originally:
In the original xv6 implementation, the sbrk() system call works by invoking growproc(). This function not only increases the process size (proc->sz) but also allocates any needed memory pages. Specifically, growproc() calls allocuvm() to map physical memory pages into the process’s address space, thereby expanding the memory region available to the process.

What breaks when modifying sbrk and why:
By removing the call to growproc() in the sys_sbrk() function of xv6 and simply incrementing proc->sz by n, the kernel no longer allocates physical memory pages when sbrk() is invoked. This change breaks programs that rely on dynamic memory allocation via sbrk(), because any attempt to access these newly “allocated” addresses triggers an error (e.g., a segmentation fault). 
The specific error message “pid 3 sh: trap 14 err 6 on cpu 0 eip 0x1260 addr 0x4004--kill proc” typically indicates a page fault or general protection fault caused by a process trying to access unmapped or unauthorized memory. In this context, it means the process is attempting to use memory beyond its valid address space, since sbrk() no longer maps physical pages for that region.

The significance of sbrk() in xv6:
The sbrk() system call is significant because it allows a process to dynamically adjust its heap size, effectively requesting more memory from the operating system as needed. It's commonly used by programs, especially those written in C, to manage dynamic memory allocation. Programs can use functions like malloc() and free() to allocate and deallocate memory within the heap. Without proper implementation of sbrk(), programs relying on dynamic memory allocation will not function correctly, leading to errors and unexpected behavior.

Part 2:
In the lazy allocation implementation, under sysproc.c the sbrk(n) system call is modified to remove the call to growproc(n), which allocates physical memory pages as the process's heap grows. Instead, sbrk(n) now simply increments the process's size (proc->sz) by n, simulating the allocation of more memory without actually mapping any physical pages at that moment.
This means that no physical memory is allocated upfront. Instead, the system delays the actual allocation of memory until the process accesses that region for the first time, which causes a page fault. When the page fault occurs, the kernel allocates a physical page and maps it to the corresponding virtual address.
During the execution of the test command, the messages "LAZY" and "Allocating New Page (1)" appeared twice. These messages were generated by the page fault handler in the trap function and indicate that lazy page allocation was triggered.
In a lazy allocation scheme, memory pages are not allocated at process creation but are instead mapped dynamically when accessed. The repeated appearance of these messages confirms that at least two page faults occurred and were successfully handled by allocating new pages on demand.
This behavior is consistent with the expected operation of lazy allocation, demonstrating that the system correctly defers memory allocation until it is actually needed during program execution.


Part 3:
The locality-aware allocation strategy builds on the lazy allocation approach by optimizing memory mapping to reduce the number of page faults. In this implementation, when a page fault occurs, the kernel not only allocates the page corresponding to the faulting address but also preemptively allocates four additional pages immediately following it. This results in a total of five consecutive pages being allocated and mapped at once.
This behavior is triggered in the trap.c,, the trap() function under the T_PGFLT case. When a page fault occurs:
1.	The faulting address is obtained using rcr2().
2.	A loop allocates five physical pages using kalloc().
3.	Each page is zeroed with memset() and mapped using mappages() at the corresponding virtual address offset from the base.

The page fault print statements in the screenshots for the lazy allocator confirm that page allocation only happens when memory is accessed, not when sbrk(n) is called. In both allocators, we see print output inside the trap handler, which is only triggered on a page fault. This shows that:
•	Allocation is deferred (lazy).
•	Page faults are being caught and resolved correctly.
The difference in allocator behavior is shown in the screenshots:
•	In lazy, one page is allocated per fault, leading to multiple traps and allocations for each accessed page. This is evident in the echo and cat outputs, where each Allocating New Page (1) appears separately.
•	In locality-aware, one fault causes five pages to be allocated up front. This is evident in the commands, where a single LOCALITY message is followed by 5 allocation prints, confirming that additional pages are preemptively mapped.
This behavior matches our expectations:
•	Lazy: many small allocations, frequent faults.
•	Locality-aware: fewer faults, more efficient for sequential access.
These outputs confirm that the trap handler correctly distinguishes between modes, allocates memory dynamically, and resumes execution after handling the fault.


Part 4:
A.Add short but informative print statements when in your page fault handling code.
To facilitate real-time debugging and better understand the system’s memory management behavior, we added concise but informative print statements in the page fault handling section of trap.c. These messages clearly indicate which memory allocation strategy is currently active—"LAZY" or "LOCALITY"—based on the compilation flag used. Additionally, whenever a new page is allocated, a message such as "Allocating New Page" is printed to the console.
These statements help visualize how the system responds to page faults and serve as a valuable tool for verifying whether the correct number of pages are being allocated under each strategy. This simple instrumentation makes the page fault mechanism observable and supports efficient debugging and evaluation of memory allocation behavior in xv6.

B.Explain how your lazy and locality-aware allocation in xv6 are implemented. 
Our implementation of lazy and locality-aware memory allocation is centered in the trap() function within trap.c, specifically under the T_PGFLT case which handles page faults.
The system determines the allocation strategy using a compile-time flag:
(1)If the LOCALITY flag is defined, the system uses locality-aware allocation.
(2)Otherwise, it defaults to lazy allocation.

In lazy allocation, the system prints "LAZY" and allocates one page in response to a page fault.
In locality-aware allocation, the system prints "LOCALITY" and allocates three pages: the faulting page and the next four pages.
This behavior is controlled by setting a variable j to either 1 (lazy) or 5 (locality-aware), and looping j times. Within the loop:
(1)A physical page is allocated using kalloc().
(2)The page is mapped into the process’s address space using mappages().
(3)The virtual address is incremented by one page size each iteration to handle the subsequent pages.

This implementation allows the system to dynamically switch between two memory allocation strategies and compare their performance. Lazy allocation is more memory-efficient, allocating memory only when needed, while locality-aware allocation prefetches additional pages to potentially reduce future page faults.

C.Explain how the page fault print statements from earlier in this section show that your page faulting algorithms are working correctly.
The print statements described earlier provide clear evidence that our page fault handling mechanisms are functioning correctly.
In lazy allocation mode, a single "Allocating New Page" message appears for each page fault, confirming that memory is allocated only on demand.
In locality-aware mode, each page fault triggers multiple allocation messages, indicating that the system is proactively allocating extra pages based on spatial locality.
By executing commands, or running custom test programs that gradually access memory, we observe the expected number of allocation messages printed to the console. This consistent behavior confirms that:

(1)Page faults are being correctly detected.
(2)The correct number of pages are being allocated according to the active strategy.
(3)Memory is being mapped and managed as designed.

These observations, combined with logs and test results, validate the correctness and effectiveness of both our lazy and locality-aware page fault handling implementations in xv6.


Run using windows 11 and i7 14700 and gcc 11.  Ubuntu 20.04.1 LTS

